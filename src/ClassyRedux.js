import {
    combineReducers,
    compose,
    createStore
} from 'redux';
import {
    camelCase,
    cloneDeep,
    isUndefined
} from 'lodash';

export class ReducerBuilder {
    constructor() {
        this.build();
    }

  /**
   * Provides the initial state of the reducer.  This initial state can either be a static object or
   * a getter method which returns the initial state (like the default implementation).
   */
    get initialState() {
        return {};
    }

    /**
     * This method (which by default is a no-op) can be overriden to add any sort of
     * "post-processing" after an action handler has been applied
     */
    afterAction(action, newState) {
    }

    /**
     * This method (which by default is a no-op) can be overriden to add any sort of
     * "pre-processing" before an action handler has been applied
     */
    beforeAction(action, newState) {
    }

    /**
     * Binds the reducer function to the ReducerBuilder.  Can be overriden to apply other reducer
     * wrapping logic (eg. Redux-Undo)
     */
    build() {
        this.reducer = this.reducer.bind(this);
    }

    /**
     * Returns a clone of the provided state
     */
    clone(oldState) {
        return _.cloneDeep(oldState);
    }

    /**
     * Returns the matching method for the provided action type, if any.
     * "Matching" in this case means the method with a name that is the same as
     * the provided action type, except camel-cased instead of underscored.
     *
     * NOTE: Redux actions look like "@@redux/INIT" but clearly neither "@@" nor
     *       "/" can be converted to camel-case (ie. we can't have a
     *       "@@redux/Init" method). For this reason, handlers for Redux actions
     *       should leave out both the "@@" and the "/".  For instance, the
     *       handler for the redux init action should be "reduxInit".
     * @param {string} actionType - an string describing an action, in Redux
     *     standard (ie. capitalized and underscored) format
     * @returns {function} - the appropriate handler for the provided action
     *     type, if any
     */
    _getHandler(actionType) {
        if (actionType.indexOf('@@') === 0) {
            // There's no way to convert @@ to camel case, so discard it (and ditto for "/")
            actionType = actionType.substr(2).replace('/');
        }
        return this[_.camelCase(actionType)];
    }

    /**
     * Determines whether the provided action is one generated by Redux itself
     */
    _isReduxInitAction({type}) {
        return type.startsWith('@@redux');
    }

    /**
     * The default reducer for all reducerBuilders.  It:
     * A) generates a new state as a deep clone of the current state
     * B) finds the appropriate handling method for the provided action
     * C) invokes it (unless it was a non-Redux action and no handler was found
     *    in which case it throws an eror)
     *
     * NOTE: Obviously cloning everything on every action is a bit overkill. If
     *       this ever becomes a performance problem this method can simply be
     *       overwritten to use a more performant method of creating the new
     *       state.
     *
     *
     * @param oldState - the current state
     * @param action - an object with a type property that desscribes the action
     * @returns {array|object} - the new state
     */
    reducer(oldState, action) {
        let newState = this.clone(isUndefined(oldState) ? this.initialState : oldState);
        if (this._isReduxInitAction(action)) return newState;

        const handler = this._getHandler(action.type);
        // Any (non-Redux initialization) action should have a matching handler
        //if (!handler) throw new Error(`Invalid action type: ${action.type}`);
        // The problem with the above thinking is that we can have multiple reducers, and any
        // given action may not work for any given reducer ... but that shouldn't throw an error

        // Create a variable to hold data that will only live for a single reducer cycle
        // TODO: Switch to this._ = {};
        // or (backwards compatible): this._  = this.reduction = {};
        this.reduction = {};

        newState = this.beforeAction(action, newState) || newState;
        newState = handler.call(this, action, newState) || newState;
        newState = this.afterAction(action, newState)|| newState;
        return this._state = newState;
    }

    /**
     * Of course the actual state is stored in Redux, not in this class, but we keep a copy of
     * the last state given to Redux as a convenience, which can be accessed through this getter.
     */
    get state() {
        return this._state;
    }
}

const isReducer = (possible) => possible.prototype instanceof ReducerBuilder;
const isNotReducer = (possible) => !isReducer(possible);

/**
 * Simple convenience class for creating a store from ReducerBuilder classes instead of
 * reducer functions.
 *
 * @param {ReducerBuilder[]|function[]} reducerBuildersAndMiddleware - 1+ Reducer builders and 0+
 *     middleware functions, all of which will be combined to create the store
 *
 * @example
 * const storeBuilder = new StoreBuilder(builder1, middleware1, builder2, middleware2, ...);
 * const reduxStore = storeBuilder.store;
 */
export class StoreBuilder {
    constructor(...reducerBuildersAndMiddleware) {
        this._middleware = reducerBuildersAndMiddleware.filter(isNotReducer);
        this._buildMiddleware();

        this._reducerBuilderClasses = reducerBuildersAndMiddleware.filter(isReducer);
        this._buildReducers();
    }
    _buildMiddleware(reducerBuildersAndMiddleware) {
        this._composedMiddleware = this.compose(...this._middleware);
    }
    _buildReducers() {
        // NOTE: We don't *need* to be storing all of these as properties of the store builder ...
        //       ... but it makes testing a whole lot easier (vs. using local variables)
        this._reducerBuilders = this._reducerBuilderClasses.map((Builder) => new Builder());
        this._reducers = this._reducerBuilders.reduce((reducers, reducerBuilder) => {
            if (!reducerBuilder.stateName) throw new Error(`Every reducer builder must have a `+
                                                           `stateName to  serve as its key in `+
                                                           `the store state`);
            reducers[reducerBuilder.stateName] = reducerBuilder.reducer;
            return reducers;
        }, {});
        this._combinedReducers = this.combineReducers(this._reducers);
    }
    /**
     * Simple alias for Redux's combineReducers (that can more easily be stubbed when testing).
     * Hypothetically if someone wanted to use a custom "combineReducers" function, this would be
     * the place to do it.
     */
    combineReducers(...args) {
        return combineReducers(...args);
    }
    /**
     * Simple alias for Redux's compose (that can more easily be stubbed when testing).
     * Hypothetically if someone wanted to use a custom "compose" function, this would be the place
     * to do it.
     */
    compose(...args) {
        return compose(...args);
    }
    /**
     * Returns a version of createStore that has been "enhanced" with the provided middleware.
     */
    get createStore() {
        return this._createStore = this._createStore || this._composedMiddleware(createStore);
    }
    get store() {
        return this._store = this._store || this.createStore(this._combinedReducers);
    }
}